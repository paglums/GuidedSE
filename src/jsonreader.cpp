#include "jsonreader.h"
#include "jsoncpp/dist/json/json.h"
#include "utils.h" 

JsonReader::JsonReader(ServerSocket * s)
{
	socket = s;
	jsonArrSize = 0;
}

/**
* Sends the current output generated by symbolic executor for the USER to the webserver 
* and sleeps, waiting for the webserver to issue instructions on how to proceed 
*/
void JsonReader::sendMessageAndSleep()
{
	if (getIsExclude() == -1)
		toSend["nodes"] = nodes;
	else
		clearNodes();
	Json::FastWriter fastWriter;
	std::string output = fastWriter.write(toSend);
	
	#ifdef DEBUG
		std::cout << "sending this: " << output << std::endl;
	#endif 

	if (socket)
		(*socket) << output;
	
	#ifdef DEBUG
		std::cout << "going to sleep" << std::endl;
	#endif

	std::unique_lock<std::mutex> lck(mtx);
	cv.wait(lck);
	lck.unlock();
	
	#ifdef DEBUG
		std::cout << "I am UP! " << std::endl;
	#endif
	
	jsonArrSize = 0;
	toSend.clear();
	
	int xyz;
	#ifdef DEBUG
		std::cin >> xyz;
	#endif
}


/**
* Conveys instruction received from the webserver to the Symbolic executor on
* how to proceed
*/

void JsonReader::proceedSymbolicExecution()
{
	#ifdef CIN_SERVER
		Json::FastWriter fastWriter;
		std::string output = fastWriter.write(toSend);
		std::cout << "got this: " << output << std::endl;
		msg = getMessage();
	#else 
		sendMessageAndSleep();
	#endif
	setExecutionVars();
}
std::vector<std::pair<ExpressionTree*, std::string> > JsonReader::getModel(
	std::map<std::string, llvm::Value*> userVarMap,
	std::map<llvm::Value*, std::string> llvmVarMap,
	std::map<llvm::Value*,ExpressionTree*> map)
{
	int xyz;
	modelRequiredForLast();
	std::vector<std::pair<ExpressionTree*, std::string> > to_ret;
	#ifdef CIN_SERVER
		Json::FastWriter fastWriter;
		std::string output = fastWriter.write(toSend);
		std::cout << "got this: " << output << std::endl;
		msg = getMessage();
	#else 
		sendMessageAndSleep();
	#endif
	Json::FastWriter fastWriter;
	std::string output = fastWriter.write(msg);
	std::cout << "message received : " << output << std::endl;
	#ifdef DEBUG
		std::cin >> xyz;
	#endif
	// steps = 0;
	for (const Json::Value& pair : msg["pairs"])
    {
    	if (steps != -1)
    		steps++;
    	ExpressionTree * tree = new ExpressionTree(pair["returnValue"].asString(),
    	 userVarMap, llvmVarMap, map);
		std::string constraint = pair["constraints"].asString();
		std::cout << "tree : " << tree->toString() << "\n";
		to_ret.push_back(std::make_pair(tree, constraint));
		std::cout << "iteration pushed!" << std::endl;
		
		#ifdef DEBUG
			std::cin >> xyz;
		#endif    
    }

    return to_ret;
}

/**
* Notifies whenever new instructions are received from the Webserver
*/

void JsonReader::wakeUp(Json::Value val)
{	
	updateMsg(val);
	
	#ifdef DEBUG
		std::cout << "WAKE UP!!!!!" << std::endl;
	#endif
	
	std::unique_lock<std::mutex> lck(mtx);
	cv.notify_all();
	
	#ifdef DEBUG
		std::cout << "DONE!!!!!" << std::endl;
	#endif
}

void JsonReader::updateMsg(Json::Value val)
{
	msg = val;
}

void JsonReader::updateToSend(Json::Value val)
{
	toSend = val;
}

/**
* Updates the variables which holds instructions for SymbolicExecutor
*/

void JsonReader::setExecutionVars()
{
	if(msg["exclude"].asString() != "")
    {
    	excludedId =  stoi(msg["exclude"].asString());
    	isExclude = stoi(msg["isNode"].asString());
	    #ifdef DEBUG
    		std::cout << "excluding! \n";
		#endif	
      	return;
    }
    isExclude = -1;
    excludedId = -1;
	isBFS = stoi(msg["isBFS"].asString());
	steps = stoi(msg["steps"].asString());
	dir = stoi(msg["branch"].asString());
	prevId = stoi(msg["prevId"].asString()); 

    #ifdef DEBUG
		std::cout << "prevId : " << prevId << "\n";
		std::cout << "isBFS : " << isBFS << "\n";
		std::cout << "branch : " << dir << "\n";
		std::cout << "steps : " << steps << "\n";
		std::cout << "proceed? : \n";
		int abc;
		std::cin >> abc;
    #endif
}

void JsonReader::addObject(Json::Value obj)
{
	nodes[jsonArrSize++] = obj;
}
void JsonReader::modelRequiredForLast()
{
	nodes[jsonArrSize-1]["addModel"] = Json::Value("true");
}
void JsonReader::initializeJsonArray()
{
	nodes = Json::arrayValue;
}

void JsonReader::clearNodes()
{
	nodes.clear();
	jsonArrSize = 0;
}